<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vacuum Robot Game</title>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background-color: #f0f9ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            user-select: none;
            max-width: 100%;
            overflow-x: hidden;
            margin: 0;
            touch-action: manipulation; /* Improve touch behavior */
        }
        
        /* Start Page Styles */
        .start-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100%;
            background-color: #e0f7ff;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            transition: opacity 0.5s ease-in-out;
        }
        
        /* Sound toggle button */
        .sound-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .sound-toggle:hover {
            transform: scale(1.1);
        }
        
        .sound-toggle img {
            width: 24px;
            height: 24px;
        }
        
        .start-title {
            font-size: 72px;
            color: #4dabf7;
            margin-bottom: 50px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.2);
            animation: float 3s infinite ease-in-out;
            text-align: center;
        }
        
        /* Robot Color Selection Styles */
        .color-selection {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
        }
        
        .color-option {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            border: 4px solid transparent;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .color-option:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(0,0,0,0.25);
        }
        
        .color-option.selected {
            border: 4px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .color-option img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .play-button {
            padding: 15px 50px;
            font-size: 36px;
            background-color: #51cf66;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .play-button:hover {
            transform: scale(1.1);
            background-color: #40c057;
            box-shadow: 0 12px 20px rgba(0,0,0,0.25);
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        /* Game Page Styles */
        .game-page {
            display: none; /* Initially hidden */
            padding-top: 20px;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-direction: row; /* Side by side layout */
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 320px;
            align-self: flex-start; /* Align with the top of the board */
        }
        
        .command-toolbar {
            display: flex;
            gap: 10px;
            background-color: #d1ecff;
            padding: 15px;
            border-radius: 8px;
            justify-content: center;
            flex-wrap: nowrap; /* Ensure commands stay in one line */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .command-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #e6f7ff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(16, 80px);
            grid-template-rows: repeat(9, 80px);
            gap: 3px;
            background-color: #ddd;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .cell {
            width: 80px;
            height: 80px;
            background-color: #fff;
            background-image: url('images/wooden-floor.jpg');
            background-size: cover;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Dust overlay on cells */
        .cell::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(120, 120, 120, 0.65); /* Semi-transparent gray dust with higher opacity */
            border-radius: 5px;
            pointer-events: none; /* Let clicks pass through */
            transition: opacity 2s ease; /* Smooth transition for dust returning */
            z-index: 3; /* Above content but below the robot */
        }
        
        /* Clean cell state */
        .cell.clean::after {
            opacity: 0; /* Dust disappears when cleaned */
        }
        
        .command {
            width: 45px;
            height: 45px;
            background-color: #fff;
            border: 2px solid #4dabf7;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        
        .command:hover {
            transform: scale(1.05);
        }
        
        .command img {
            width: 35px;
            height: 35px;
        }
        
        .sequence-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        .sequence-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }
        
        .slot {
            width: 100%;
            height: 50px;
            background-color: #f8f9fa;
            border: 2px dashed #adb5bd;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .slot::before {
            content: attr(data-index);
            position: absolute;
            left: 10px;
            font-weight: bold;
            color: #adb5bd;
        }
        
        .slot.filled {
            border: 2px solid #4dabf7;
            background-color: #e7f5ff;
        }
        
        .start-button {
            padding: 10px 20px;
            background-color: #51cf66;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            margin-top: 5px;
        }
        
        .start-button:hover {
            transform: scale(1.05);
            background-color: #40c057;
        }
        
        .start-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }
        
        .robot {
            width: 70px;
            height: 70px;
            position: absolute;
            transition: transform 0.8s;
            z-index: 4; /* Higher than the dust layer */
            filter: drop-shadow(0 3px 3px rgba(0,0,0,0.2));
        }
        
        .mess {
            width: 60px;
            height: 60px;
            position: absolute;
            z-index: 2; /* Above the floor but below the dust */
        }
        
        .obstacle {
            width: 70px;
            height: 70px;
            position: absolute;
            z-index: 2; /* Above the floor but below the dust */
        }
        
        .current {
            background-color: #ffe066;
            border: 3px solid #ffd43b;
            box-shadow: 0 0 10px rgba(255, 212, 59, 0.5);
            animation: pulse 1s infinite;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .score-display {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-size: 24px;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            background-color: #fff5f5;
            border: 3px solid #ffc9c9;
            border-radius: 15px;
            padding: 10px 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: calc(16 * 80px + 15 * 3px + 20px); /* Match board width: 16 cells + 15 gaps + padding */
            box-sizing: border-box;
            margin-top: 10px;
            animation: pulse-light 2s infinite;
        }
        
        #score-value {
            font-weight: bold;
            font-size: 28px;
            color: #fa5252;
            margin-left: 5px;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 212, 59, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 212, 59, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 212, 59, 0.5); }
        }
        
        @keyframes pulse-light {
            0% { box-shadow: 0 0 5px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 107, 107, 0.5); }
        }
        
        @keyframes clean {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        .cleaning {
            animation: clean 0.5s forwards;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0) rotate(var(--rotation, 0deg)); }
            50% { transform: translateY(-5px) rotate(var(--rotation, 0deg)); }
        }
        
        .bounce {
            animation: bounce 0.5s;
            --rotation: 0deg;
        }
        
        @keyframes collision {
            0%, 100% { transform: translateX(0) rotate(var(--rotation, 0deg)); }
            25% { transform: translateX(-5px) rotate(var(--rotation, 0deg)); }
            50% { transform: translateX(5px) rotate(var(--rotation, 0deg)); }
            75% { transform: translateX(-5px) rotate(var(--rotation, 0deg)); }
        }
        
        .collision {
            animation: collision 0.5s;
        }
        
        /* Preserve rotation during animation */
        .robot[style*="rotate(-90deg)"] {
            --rotation: -90deg;
        }
        
        .robot[style*="rotate(90deg)"] {
            --rotation: 90deg;
        }
        
        .robot[style*="rotate(180deg)"] {
            --rotation: 180deg;
        }
    </style>
</head>
<body>
    <!-- Start Page -->
    <div class="start-page" id="start-page">
        <h1 class="start-title">Vacuum Robot Game</h1>
        
        <!-- Sound toggle button -->
        <div class="sound-toggle" id="sound-toggle">
            <img src="/api/placeholder/24/24" alt="Sound" id="sound-icon">
        </div>
        
        <!-- Color Selection -->
        <div class="color-selection" id="color-selection">
            <div class="color-option selected" data-color="light-blue">
                <img src="/api/placeholder/80/80" alt="Light Blue Robot" id="light-blue-img">
            </div>
            <div class="color-option" data-color="dark-blue">
                <img src="/api/placeholder/80/80" alt="Dark Blue Robot" id="dark-blue-img">
            </div>
            <div class="color-option" data-color="pink">
                <img src="/api/placeholder/80/80" alt="Pink Robot" id="pink-img">
            </div>
            <div class="color-option" data-color="light-green">
                <img src="/api/placeholder/80/80" alt="Light Green Robot" id="light-green-img">
            </div>
        </div>
        
        <button class="play-button" id="play-button">PLAY</button>
    </div>
    
    <!-- Game Page -->
    <div class="game-page" id="game-page">
        <div class="game-container">
            <!-- Left Column: Command Bar and Sequence List -->
            <div class="left-panel">
                <!-- Command Selection Bar on top -->
                <div class="command-toolbar">
                    <div class="command" data-type="forward" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Forward" id="forward-img">
                    </div>
                    <div class="command" data-type="left" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Turn Left" id="left-img">
                    </div>
                    <div class="command" data-type="right" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Turn Right" id="right-img">
                    </div>
                    <div class="command" data-type="uturn" draggable="true">
                        <img src="/api/placeholder/50/50" alt="U-Turn" id="uturn-img">
                    </div>
                    <div class="command" data-type="clean" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Clean" id="clean-img">
                    </div>
                </div>
                
                <!-- Command Panel with Sequence list below -->
                <div class="command-panel">
                    <button class="start-button" id="start-button">▶ Start</button>
                    <div class="sequence-list">
                        <div class="sequence-slots" id="sequence-slots">
                            <!-- Command slots will be generated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column: Game Board and Score -->
            <div class="right-panel">
                <!-- Game Board on top -->
                <div class="board" id="game-board">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
                
                <!-- Score display below the board -->
                <div class="score-display">
                    <span>Score:</span>
                    <span id="score-value">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const GRID_COLS = 16;
        const GRID_ROWS = 9;
        const MAX_OBJECTS = 8; // Reduced to make room for obstacles
        const MAX_OBSTACLES = 5; // Number of obstacles to spawn
        const MAX_COMMANDS = 10;
        const MOVE_DELAY = 1200; // milliseconds between command execution
        
        let score = 0;
        let selectedRobotColor = 'light-blue'; // Default color
        let soundEnabled = true; // Sound is enabled by default
        
        // Sound effects - preload with fallback method
        const sounds = {};
        const soundCache = {}; // Cache for pre-created Audio objects
        
        // Function to create and load sounds with multiple approaches
        function loadSounds() {
            const soundFiles = {
                click: 'sounds/click.mp3',
                drop: 'sounds/drop.mp3',
                move: 'sounds/move.mp3',
                collision: 'sounds/collision.mp3',
                clean: 'sounds/clean.mp3',
                score: 'sounds/score.mp3'
            };
            
            // Start audio context on user interaction (to help with autoplay policies)
            let audioContextStarted = false;
            document.addEventListener('click', function initAudio() {
                if (!audioContextStarted) {
                    // Create an AudioContext to help with browser audio policies
                    try {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        const audioCtx = new AudioContext();
                        console.log("AudioContext created:", audioCtx.state);
                        
                        // Try to resume if suspended
                        if (audioCtx.state === 'suspended') {
                            audioCtx.resume().then(() => {
                                console.log("AudioContext resumed successfully");
                            });
                        }
                    } catch (e) {
                        console.error("Failed to create AudioContext:", e);
                    }
                    
                    // Initialize sounds on first click
                    for (const [name, path] of Object.entries(soundFiles)) {
                        try {
                            sounds[name] = new Audio(path);
                            // Force preload
                            sounds[name].load();
                            
                            // Also pre-create some cached Audio objects for faster playing
                            soundCache[name] = [
                                new Audio(path),
                                new Audio(path),
                                new Audio(path)
                            ];
                            
                            console.log(`Sound initialized on click: ${name}`);
                        } catch (e) {
                            console.error(`Failed to initialize sound ${name}:`, e);
                        }
                    }
                    
                    // Try to play a silent sound to unblock audio
                    try {
                        const silentSound = new Audio('data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjEyLjEwMAAAAAAAAAAAAAAA//tUAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV6urq6urq6urq6urq6urq6urq6urq6urq6v////////////////////////////////8AAAAATGF2YzU4LjIxAAAAAAAAAAAAAAAAJAAAAAAAAAAAECBFtDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7dEAAAbNIJIFPeACKeHWPLeEAtEglSW9gAK2ImK3vAARsQEDIxMQELzQAgQMSE59GfxkGfcHmGT/SHf/8wHnf4SPtLv//5gHnGQb/+oEDEo3XIAAAAHAEQTDQMKDQ4S/xU+a+FJt/lAxmYxRk4ZKEpIKCDlQDKSkZ48/+VkdWZycQZ1DbuREmgbKfS2+lJdcCPBsZ9lb0YbzYSdkVzKVc7PDVv/PVvJGK/gg1a+zJGVO5X/yCYLlmCCN1bUCrW7ltfb7WZPSqfb/nVPJ6S6daiRRXZ1fpfzqnj+ikbJWhUOYk98/wgXf/9Zvf2EAAAAAACknEHXEACEAYSLj5YYXP5Yf7lE8HA0FtBK8TGOo8XzfJAGP0yGCGWfgwl2hShRdj9FfLwV5KnU83CkNkFzKQxIW9aXbsvCwHRA74ZAKCxhAxIQSQ1zyQjWnpdwRCDxhRINEDDi5ELzEBBYwgQEJGHCxS7Vj4CCjlx8SmdKK1V1fS0EAGTqcQpqz1f5yzqPQmFOBMALDOmyMbFAw7LSVqzlWBwAfwlmIbr4hI1IVHMGLOFqwADT8z45hy97GAAwIMfD/Xc6SX//5VUMfhE1c////p/M7Of/0EPGVS//71WQUsRBgAAAAAwMDAwQAOw==');
                        silentSound.volume = 0.01;
                        silentSound.play();
                    } catch (e) {
                        console.warn("Could not play silent sound:", e);
                    }
                    
                    audioContextStarted = true;
                }
                document.removeEventListener('click', initAudio);
            });
            
            // Also load them normally as backup
            for (const [name, path] of Object.entries(soundFiles)) {
                try {
                    sounds[name] = new Audio(path);
                    
                    // Force preload
                    sounds[name].load();
                    
                    // Log when sound is loaded
                    sounds[name].addEventListener('canplaythrough', () => {
                        console.log(`Sound loaded: ${name}`);
                    }, { once: true });
                    
                    // Log errors
                    sounds[name].addEventListener('error', (e) => {
                        console.error(`Error loading sound ${name}:`, e);
                    });
                } catch (e) {
                    console.error(`Failed to create sound ${name}:`, e);
                }
            }
            
            console.log('All sounds initialized');
        }
        
        // Load sounds immediately
        loadSounds();
        
        // Function to play sounds with better debugging and fallback
        function playSound(soundName) {
            console.log(`Attempting to play sound: ${soundName}`);
            
            if (!soundEnabled) {
                console.log('Sound is disabled');
                return;
            }
            
            if (!sounds[soundName]) {
                console.error(`Sound not found: ${soundName}`);
                return;
            }
            
            try {
                // Create a brand new Audio object with direct path reference
                const soundPath = sounds[soundName].src;
                console.log(`Playing sound from path: ${soundPath}`);
                
                const soundToPlay = new Audio(soundPath);
                soundToPlay.volume = 0.7;
                
                // Log success or error
                soundToPlay.addEventListener('play', () => {
                    console.log(`Sound ${soundName} started playing successfully`);
                });
                
                soundToPlay.addEventListener('error', (e) => {
                    console.error(`Error event on sound ${soundName}:`, e);
                });
                
                // Force play and handle errors
                const playPromise = soundToPlay.play();
                
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log(`Sound ${soundName} promise resolved`);
                    }).catch(e => {
                        console.error(`Error playing sound ${soundName}:`, e);
                        
                        // Try a different approach for mobile
                        setTimeout(() => {
                            try {
                                soundToPlay.play();
                            } catch (err) {
                                console.error('Alternative play attempt failed');
                            }
                        }, 100);
                    });
                }
            } catch (e) {
                console.error(`Exception playing sound: ${soundName}`, e);
            }
        }
        
        let robot = {
            x: 0,
            y: 0,
            direction: 'right', // 'up', 'right', 'down', 'left'
            element: null,
            isMoving: false,
            color: selectedRobotColor
        };
        
        let messes = [];
        let obstacles = []; // New array to track obstacles
        let commandSequence = [];
        let isRunning = false;
        
        // Robot colors
        const robotColors = {
            'light-blue': 'images/vacuumrobot-lightblue.png',
            'dark-blue': 'images/vacuumrobot-darkblue.png',
            'pink': 'images/vacuumrobot-pink.png',
            'light-green': 'images/vacuumrobot-lightgreen.png'
        };
        
        // Visual resources using local image files
        const messImages = [
            'images/spider.png',      // spider
            'images/icecream.png',    // ice cream
            'images/bread.png',       // bread
            'images/pan.png',         // pan
            'images/oil.png'          // oil
        ];
        
        // Obstacle images
        const obstacleImages = [
            'images/sofa.png', // Sofa
            'images/table.png', // Table
            'images/toy.png'  // Toy
        ];
        
        // Set up color selection functionality
        function setupColorSelection() {
            const colorOptions = document.querySelectorAll('.color-option');
            
            // Set robot images for color options
            document.getElementById('light-blue-img').src = 'images/vacuumrobot-lightblue.png';
            document.getElementById('dark-blue-img').src = 'images/vacuumrobot-darkblue.png';
            document.getElementById('pink-img').src = 'images/vacuumrobot-pink.png';
            document.getElementById('light-green-img').src = 'images/vacuumrobot-lightgreen.png';
            
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    // Play click sound
                    playSound('click');
                    
                    // Remove selected class from all options
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    
                    // Add selected class to clicked option
                    this.classList.add('selected');
                    
                    // Update selected color
                    selectedRobotColor = this.dataset.color;
                    
                    // Apply a bounce animation
                    this.classList.add('bounce');
                    setTimeout(() => {
                        this.classList.remove('bounce');
                    }, 500);
                });
            });
        }
        
        // Initialize color selection when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            setupColorSelection();
            setupSoundToggle();
        });
        
        // Set up sound toggle functionality
        function setupSoundToggle() {
            const soundToggle = document.getElementById('sound-toggle');
            const soundIcon = document.getElementById('sound-icon');
            
            // Set initial sound icon
            soundIcon.src = soundEnabled ? 'images/sound-on.png' : 'images/sound-off.png';
            
            soundToggle.addEventListener('click', function() {
                // Toggle sound state
                soundEnabled = !soundEnabled;
                
                // Update icon
                soundIcon.src = soundEnabled ? 'images/sound-on.png' : 'images/sound-off.png';
                
                // Play sound if enabling
                if (soundEnabled) {
                    // Force load/reload sounds when enabling
                    loadSounds();
                    
                    // Try playing with a slight delay
                    setTimeout(() => {
                        playSound('click');
                    }, 100);
                }
                
                console.log(`Sound is now ${soundEnabled ? 'enabled' : 'disabled'}`);
            });
        }
        
        // Play button to start the game
        document.getElementById('play-button').addEventListener('click', function() {
            // Play click sound
            playSound('click');
            
            // Save the selected color before transitioning
            robot.color = selectedRobotColor;
            
            // Hide start page with a fade effect
            const startPage = document.getElementById('start-page');
            startPage.style.opacity = 0;
            
            // Show game page after fade
            setTimeout(() => {
                startPage.style.display = 'none';
                document.getElementById('game-page').style.display = 'block';
                initGame(); // Initialize the game after showing the game page
            }, 500);
        });
        
        // Initialize the game
        function initGame() {
            createBoard();
            createCommandSlots();
            setupDragAndDrop();
            placeRobot();
            spawnRandomObstacles(); // Place obstacles first
            spawnRandomMesses();     // Then place messes
            
            // Clean the starting cell (robot's position)
            cleanCell(robot.x, robot.y);
            
            // Reset score
            score = 0;
            document.getElementById('score-value').textContent = score;
            
            // Set up start button
            document.getElementById('start-button').addEventListener('click', function() {
                playSound('click'); // Play click sound
                startExecution();
            });
            
            // Command icons
            document.getElementById('forward-img').src = 'images/forward.png';
            document.getElementById('left-img').src = 'images/left.png';
            document.getElementById('right-img').src = 'images/right.png';
            document.getElementById('uturn-img').src = 'images/uturn.png';
            document.getElementById('clean-img').src = 'images/clean.png';
        }
        
        // Create the game board
        function createBoard() {
            const board = document.getElementById('game-board');
            board.innerHTML = '';
            
            for (let y = 0; y < GRID_ROWS; y++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    board.appendChild(cell);
                }
            }
        }
        
        // Create command sequence slots
        function createCommandSlots() {
            const slotsContainer = document.getElementById('sequence-slots');
            slotsContainer.innerHTML = '';
            
            for (let i = 0; i < MAX_COMMANDS; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.index = i + 1;
                slotsContainer.appendChild(slot);
            }
        }
        
        // Place the robot at the start position
        function placeRobot() {
            robot.x = 0;
            robot.y = GRID_ROWS - 1; // Bottom-left corner
            robot.direction = 'up';  // Starting facing up
            
            if (!robot.element) {
                // Create a container for the robot image
                robot.element = document.createElement('div');
                robot.element.className = 'robot';
                
                // Use the selected color for the robot image
                const robotImg = document.createElement('img');
                robotImg.src = robotColors[robot.color]; // Use the selected color
                robotImg.alt = 'Vacuum Robot';
                robotImg.style.width = '70px';
                robotImg.style.height = '70px';
                robotImg.style.borderRadius = '50%'; // Keep circular shape
                robotImg.style.transform = 'rotate(90deg)'; // Rotate the image 90° clockwise
                
                robot.element.appendChild(robotImg);
            } else {
                // Update the robot image to match the selected color
                const robotImg = robot.element.querySelector('img');
                robotImg.src = robotColors[robot.color];
            }
            
            updateRobotPosition();
        }
        
        // Clean the cell when the robot moves over it
        function cleanCell(x, y) {
            const cell = getCellAt(x, y);
            if (cell) {
                // Add the clean class to make the cell appear clean
                cell.classList.add('clean');
                
                // Set a timer to gradually make the cell dusty again
                setTimeout(() => {
                    // Only make it dusty if the robot is no longer on this cell
                    if (cell && !(robot.x === x && robot.y === y)) {
                        cell.classList.remove('clean');
                    }
                }, 16000); // Dust returns after 16 seconds (2x slower)
            }
        }
        
        // Update the robot's visual position and rotation
        function updateRobotPosition() {
            const cell = getCellAt(robot.x, robot.y);
            if (cell && robot.element) {
                cell.appendChild(robot.element);
                
                // Clean the current cell
                cleanCell(robot.x, robot.y);
                
                // Update rotation based on direction
                switch (robot.direction) {
                    case 'up':
                        robot.element.style.transform = 'rotate(-90deg)';
                        break;
                    case 'right':
                        robot.element.style.transform = 'rotate(0deg)';
                        break;
                    case 'down':
                        robot.element.style.transform = 'rotate(90deg)';
                        break;
                    case 'left':
                        robot.element.style.transform = 'rotate(180deg)';
                        break;
                }
                
                // Small bounce animation when moving
                robot.element.classList.add('bounce');
                setTimeout(() => {
                    robot.element.classList.remove('bounce');
                }, 500);
            }
        }
        
        // Get cell element at coordinates
        function getCellAt(x, y) {
            return document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
        }
        
        // Spawn random obstacles on the board
        function spawnRandomObstacles() {
            obstacles = []; // Clear existing obstacles
            
            const safeZone = { // Define a safe zone around the robot's starting position
                minX: 0,
                maxX: 2,
                minY: GRID_ROWS - 3,
                maxY: GRID_ROWS - 1
            };
            
            let count = 0;
            while (count < MAX_OBSTACLES) {
                const x = Math.floor(Math.random() * GRID_COLS);
                const y = Math.floor(Math.random() * GRID_ROWS);
                
                // Don't place in the safe zone
                if (x >= safeZone.minX && x <= safeZone.maxX && 
                    y >= safeZone.minY && y <= safeZone.maxY) {
                    continue;
                }
                
                // Don't place where another obstacle exists
                if (obstacles.some(o => o.x === x && o.y === y)) {
                    continue;
                }
                
                const cell = getCellAt(x, y);
                
                // Remove dust from cells with obstacles
                cell.classList.add('clean');
                
                const obstacleElement = document.createElement('img');
                obstacleElement.className = 'obstacle';
                
                // Pick a random obstacle image
                const imageIndex = Math.floor(Math.random() * obstacleImages.length);
                obstacleElement.src = obstacleImages[imageIndex];
                
                // Set alt text based on obstacle type
                switch(imageIndex) {
                    case 0:
                        obstacleElement.alt = 'Sofa';
                        break;
                    case 1:
                        obstacleElement.alt = 'Table';
                        break;
                    case 2:
                        obstacleElement.alt = 'Toy';
                        break;
                }
                
                cell.appendChild(obstacleElement);
                
                obstacles.push({
                    x: x,
                    y: y,
                    element: obstacleElement,
                    type: obstacleElement.alt
                });
                
                count++;
            }
        }
        
        // Spawn random messes on the board
        function spawnRandomMesses() {
            // Clear existing messes that aren't already on the board
            messes = messes.filter(mess => document.body.contains(mess.element));
            
            // Add new messes if we're below the maximum
            while (messes.length < MAX_OBJECTS) {
                const x = Math.floor(Math.random() * GRID_COLS);
                const y = Math.floor(Math.random() * GRID_ROWS);
                
                // Don't place mess on robot
                if (x === robot.x && y === robot.y) continue;
                
                // Don't place mess where one already exists
                if (messes.some(m => m.x === x && m.y === y)) continue;
                
                // Don't place mess where an obstacle exists
                if (obstacles.some(o => o.x === x && o.y === y)) continue;
                
                const cell = getCellAt(x, y);
                
                // Remove dust from cells with messes
                cell.classList.add('clean');
                
                const messElement = document.createElement('img');
                messElement.className = 'mess';
                
                // Pick a random mess image
                const imageIndex = Math.floor(Math.random() * messImages.length);
                messElement.src = messImages[imageIndex];
                messElement.alt = 'Mess';
                
                cell.appendChild(messElement);
                
                messes.push({
                    x: x,
                    y: y,
                    element: messElement
                });
            }
        }
        
        // Set up drag and drop functionality with touch support
        function setupDragAndDrop() {
            const commands = document.querySelectorAll('.command');
            const slots = document.querySelectorAll('.slot');
            let draggedElement = null;
            let touchDragClone = null;
            let currentTouchedSlot = null;
            let startX, startY;
            
            // Helper function to add command to a slot
            function addCommandToSlot(slot, commandType) {
                console.log("Adding command to slot:", commandType);
                const index = parseInt(slot.dataset.index);
                
                // Clear existing command in this slot
                while (slot.firstChild) {
                    slot.removeChild(slot.firstChild);
                }
                
                // Add new command
                const commandImg = document.createElement('img');
                commandImg.style.width = '35px';
                commandImg.style.height = '35px';
                
                switch (commandType) {
                    case 'forward':
                        commandImg.src = 'images/forward.png';
                        commandImg.alt = '↑';
                        break;
                    case 'left':
                        commandImg.src = 'images/left.png';
                        commandImg.alt = '←';
                        break;
                    case 'right':
                        commandImg.src = 'images/right.png';
                        commandImg.alt = '→';
                        break;
                    case 'uturn':
                        commandImg.src = 'images/uturn.png';
                        commandImg.alt = '↺';
                        break;
                    case 'clean':
                        commandImg.src = 'images/clean.png';
                        commandImg.alt = '✓';
                        break;
                }
                
                slot.appendChild(commandImg);
                slot.classList.add('filled');
                slot.dataset.command = commandType;
                
                // Update command sequence
                commandSequence[index] = commandType;
                
                // Show animation feedback
                slot.classList.add('bounce');
                setTimeout(() => {
                    slot.classList.remove('bounce');
                }, 500);
                
                // Explicitly play drop sound here
                setTimeout(() => {
                    playSound('drop');
                }, 10);
            }
            
            // Helper function to create a visual clone for touch dragging
            function createDragClone(element) {
                const rect = element.getBoundingClientRect();
                const clone = element.cloneNode(true);
                
                clone.style.position = 'fixed';
                clone.style.left = `${rect.left}px`;
                clone.style.top = `${rect.top}px`;
                clone.style.width = `${rect.width}px`;
                clone.style.height = `${rect.height}px`;
                clone.style.zIndex = '1000';
                clone.style.opacity = '0.8';
                clone.style.pointerEvents = 'none'; // So it doesn't interfere with touch events
                clone.style.boxShadow = '0 5px 15px rgba(0,0,0,0.2)';
                
                document.body.appendChild(clone);
                return clone;
            }
            
            // Mouse events for drag and drop
            commands.forEach(command => {
                command.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', command.dataset.type);
                    setTimeout(() => {
                        command.style.opacity = '0.4';
                    }, 0);
                });
                
                command.addEventListener('dragend', () => {
                    command.style.opacity = '1';
                });
            });
            
            slots.forEach(slot => {
                slot.addEventListener('dragover', e => {
                    e.preventDefault();
                    slot.style.backgroundColor = '#e7f5ff';
                });
                
                slot.addEventListener('dragleave', () => {
                    slot.style.backgroundColor = '';
                });
                
                slot.addEventListener('drop', e => {
                    e.preventDefault();
                    const commandType = e.dataTransfer.getData('text/plain');
                    addCommandToSlot(slot, commandType);
                });
                
                // Double click to remove command
                slot.addEventListener('dblclick', () => {
                    // Clear slot
                    while (slot.firstChild) {
                        slot.removeChild(slot.firstChild);
                    }
                    
                    slot.classList.remove('filled');
                    delete slot.dataset.command;
                    
                    // Update command sequence
                    const index = parseInt(slot.dataset.index);
                    commandSequence[index] = null;
                });
                
                // Touch event for double tap to remove (for touch devices)
                let lastTap = 0;
                slot.addEventListener('touchend', (e) => {
                    // Only handle if it's a quick tap, not a drag
                    if (!touchDragClone && slot.classList.contains('filled')) {
                        const currentTime = new Date().getTime();
                        const tapLength = currentTime - lastTap;
                        if (tapLength < 300 && tapLength > 0) {
                            // Double tap detected
                            e.preventDefault(); // Prevent zoom and other gestures
                            
                            // Clear slot (same as double click handler)
                            while (slot.firstChild) {
                                slot.removeChild(slot.firstChild);
                            }
                            
                            slot.classList.remove('filled');
                            delete slot.dataset.command;
                            
                            // Update command sequence
                            const index = parseInt(slot.dataset.index);
                            commandSequence[index] = null;
                        }
                        lastTap = currentTime;
                    }
                });
            });
            
            // Touch events for drag and drop
            commands.forEach(command => {
                command.addEventListener('touchstart', (e) => {
                    if (isRunning) return; // Don't allow dragging while game is running
                    
                    // Store initial position
                    const touch = e.touches[0];
                    startX = touch.clientX;
                    startY = touch.clientY;
                    
                    // Mark this command as being dragged
                    draggedElement = command;
                }, { passive: false });
            });
            
            // Add touch move to the document to track dragging
            document.addEventListener('touchmove', (e) => {
                if (!draggedElement) return;
                
                e.preventDefault(); // Prevent scrolling while dragging
                
                const touch = e.touches[0];
                const moveX = touch.clientX - startX;
                const moveY = touch.clientY - startY;
                
                // If movement is significant, create a visual clone if not already
                if (!touchDragClone && (Math.abs(moveX) > 10 || Math.abs(moveY) > 10)) {
                    touchDragClone = createDragClone(draggedElement);
                    draggedElement.style.opacity = '0.4'; // Dim the original
                }
                
                // Move the clone with the touch
                if (touchDragClone) {
                    touchDragClone.style.left = `${touch.clientX - touchDragClone.offsetWidth / 2}px`;
                    touchDragClone.style.top = `${touch.clientY - touchDragClone.offsetHeight / 2}px`;
                    
                    // Check if we're over a slot
                    const prevTouchedSlot = currentTouchedSlot;
                    currentTouchedSlot = null;
                    
                    // Reset previous slot if it exists
                    if (prevTouchedSlot) {
                        prevTouchedSlot.style.backgroundColor = '';
                    }
                    
                    // Find if we're over a slot
                    slots.forEach(slot => {
                        const rect = slot.getBoundingClientRect();
                        if (
                            touch.clientX >= rect.left && 
                            touch.clientX <= rect.right && 
                            touch.clientY >= rect.top && 
                            touch.clientY <= rect.bottom
                        ) {
                            slot.style.backgroundColor = '#e7f5ff'; // Highlight
                            currentTouchedSlot = slot;
                        }
                    });
                }
            }, { passive: false });
            
            // Touch end to finish the drag
            document.addEventListener('touchend', (e) => {
                if (!draggedElement) return;
                
                // If we have a clone and are over a slot, "drop" the command
                if (touchDragClone && currentTouchedSlot) {
                    console.log("Touch drop detected");
                    addCommandToSlot(currentTouchedSlot, draggedElement.dataset.type);
                    currentTouchedSlot.style.backgroundColor = '';
                    
                    // Sound is now played in addCommandToSlot
                }
                
                // Clean up
                if (touchDragClone) {
                    document.body.removeChild(touchDragClone);
                    touchDragClone = null;
                }
                
                if (draggedElement) {
                    draggedElement.style.opacity = '1';
                    draggedElement = null;
                }
                
                currentTouchedSlot = null;
            });
            
            // Touch cancel to abort the drag
            document.addEventListener('touchcancel', (e) => {
                // Clean up everything
                if (touchDragClone) {
                    document.body.removeChild(touchDragClone);
                    touchDragClone = null;
                }
                
                if (draggedElement) {
                    draggedElement.style.opacity = '1';
                    draggedElement = null;
                }
                
                if (currentTouchedSlot) {
                    currentTouchedSlot.style.backgroundColor = '';
                    currentTouchedSlot = null;
                }
            });
        }
        
        // Start executing the command sequence
        function startExecution() {
            if (isRunning) return;
            
            // Clear any existing highlights
            document.querySelectorAll('.slot').forEach(slot => {
                slot.classList.remove('current');
            });
            
            // Sort commands by slot index and collect them
            const filledSlots = Array.from(document.querySelectorAll('.slot'))
                .filter(slot => slot.dataset.command)
                .sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
                
            commandSequence = filledSlots.map(slot => slot.dataset.command);
            
            if (commandSequence.length === 0) return;
            
            isRunning = true;
            document.getElementById('start-button').disabled = true;
            
            // Disable drag and drop during execution for both mouse and touch
            document.querySelectorAll('.command').forEach(cmd => {
                cmd.setAttribute('draggable', 'false');
                cmd.style.cursor = 'default';
                cmd.style.touchAction = 'auto'; // Disable touch events for dragging during execution
            });
            
            executeCommands();
        }
        
        // Execute commands one by one
        function executeCommands() {
            let currentIndex = 0;
            const slots = document.querySelectorAll('.slot');
            
            // Clear any previous highlights first
            slots.forEach(slot => slot.classList.remove('current'));
            
            function executeNext() {
                if (currentIndex >= commandSequence.length || !isRunning) {
                    endExecution();
                    return;
                }
                
                // Find the slot corresponding to the current command
                const currentSlot = Array.from(slots).find(slot => 
                    parseInt(slot.dataset.index) === currentIndex + 1 && 
                    slot.dataset.command === commandSequence[currentIndex]
                );
                
                // Highlight current command
                if (currentSlot) {
                    slots.forEach(slot => slot.classList.remove('current'));
                    currentSlot.classList.add('current');
                    // Scroll to the current command if needed
                    currentSlot.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                const command = commandSequence[currentIndex];
                executeCommand(command);
                
                currentIndex++;
                setTimeout(executeNext, MOVE_DELAY);
            }
            
            executeNext();
        }
        
        // Execute a single command
        function executeCommand(command) {
            console.log(`Executing command: ${command}`);
            
            // Pre-play sound based on command type
            if (command === 'forward' || command === 'left' || command === 'right' || command === 'uturn') {
                console.log("Playing move sound for command:", command);
                playSound('move');
            } else if (command === 'clean') {
                console.log("Playing clean sound for command:");
                playSound('clean');
            }
            
            // Small delay to let sound start before animation
            setTimeout(() => {
                switch (command) {
                    case 'forward':
                        moveForward();
                        break;
                    case 'left':
                        turnLeft();
                        break;
                    case 'right':
                        turnRight();
                        break;
                    case 'uturn':
                        turnAround();
                        break;
                    case 'clean':
                        clean();
                        break;
                }
            }, 50);
        }
        
        // Move the robot forward
        function moveForward() {
            let newX = robot.x;
            let newY = robot.y;
            
            switch (robot.direction) {
                case 'up':
                    newY--;
                    break;
                case 'right':
                    newX++;
                    break;
                case 'down':
                    newY++;
                    break;
                case 'left':
                    newX--;
                    break;
            }
            
            // Check if the new position is within bounds
            if (newX >= 0 && newX < GRID_COLS && newY >= 0 && newY < GRID_ROWS) {
                // Check if there's an obstacle in the way
                const obstacleIndex = obstacles.findIndex(obstacle => 
                    obstacle.x === newX && obstacle.y === newY
                );
                
                if (obstacleIndex !== -1) {
                    // Hit an obstacle - show collision animation and end execution
                    robot.element.classList.add('collision');
                    
                    // Play collision sound
                    playSound('collision');
                    
                    setTimeout(() => {
                        robot.element.classList.remove('collision');
                    }, 500);
                    
                    // Show what obstacle was hit
                    console.log(`Robot hit a ${obstacles[obstacleIndex].type}!`);
                    
                    // End execution after animation
                    setTimeout(() => {
                        endExecution();
                    }, 600);
                } else {
                    // Move to the new position
                    robot.x = newX;
                    robot.y = newY;
                    updateRobotPosition();
                }
            } else {
                // Hit the border, stop execution
                robot.element.classList.add('collision');
                
                // Play collision sound
                playSound('collision');
                
                setTimeout(() => {
                    robot.element.classList.remove('collision');
                }, 500);
                
                setTimeout(() => {
                    endExecution();
                }, 600);
            }
        }
        
        // Turn the robot left
        function turnLeft() {
            switch (robot.direction) {
                case 'up':
                    robot.direction = 'left';
                    break;
                case 'right':
                    robot.direction = 'up';
                    break;
                case 'down':
                    robot.direction = 'right';
                    break;
                case 'left':
                    robot.direction = 'down';
                    break;
            }
            updateRobotPosition();
        }
        
        // Turn the robot right
        function turnRight() {
            switch (robot.direction) {
                case 'up':
                    robot.direction = 'right';
                    break;
                case 'right':
                    robot.direction = 'down';
                    break;
                case 'down':
                    robot.direction = 'left';
                    break;
                case 'left':
                    robot.direction = 'up';
                    break;
            }
            updateRobotPosition();
        }
        
        // Turn the robot around (180 degrees)
        function turnAround() {
            switch (robot.direction) {
                case 'up':
                    robot.direction = 'down';
                    break;
                case 'right':
                    robot.direction = 'left';
                    break;
                case 'down':
                    robot.direction = 'up';
                    break;
                case 'left':
                    robot.direction = 'right';
                    break;
            }
            updateRobotPosition();
        }
        
        // Clean the current cell
        function clean() {
            const messIndex = messes.findIndex(mess => 
                mess.x === robot.x && mess.y === robot.y
            );
            
            if (messIndex !== -1) {
                const mess = messes[messIndex];
                mess.element.classList.add('cleaning');
                
                // Increase score
                score += 1;
                document.getElementById('score-value').textContent = score;
                
                // Add score animation
                const scoreElement = document.getElementById('score-value');
                scoreElement.classList.add('bounce');
                
                // Play score sound
                playSound('score');
                
                setTimeout(() => {
                    scoreElement.classList.remove('bounce');
                }, 500);
                
                // Remove the mess after animation
                setTimeout(() => {
                    if (mess.element.parentNode) {
                        mess.element.parentNode.removeChild(mess.element);
                    }
                    messes.splice(messIndex, 1);
                    
                    // Spawn a new mess
                    setTimeout(spawnRandomMesses, 500);
                }, 500);
            }
        }
        
        // End command execution
        function endExecution() {
            isRunning = false;
            document.getElementById('start-button').disabled = false;
            
            // Re-enable drag and drop for mouse and touch
            document.querySelectorAll('.command').forEach(cmd => {
                cmd.setAttribute('draggable', 'true');
                cmd.style.cursor = 'grab';
                cmd.style.touchAction = 'none'; // Enable touch events for dragging
            });
            
            // Remove highlighting
            document.querySelectorAll('.slot').forEach(slot => {
                slot.classList.remove('current');
            });
            
            // Clear sequence list immediately
            document.querySelectorAll('.slot').forEach(slot => {
                // Remove any children
                while (slot.firstChild) {
                    slot.removeChild(slot.firstChild);
                }
                // Clear classes and data attributes
                slot.classList.remove('filled');
                delete slot.dataset.command;
            });
            
            // Reset command sequence array
            commandSequence = [];
        }
        
        // Note: We don't initialize the game here anymore
        // It will be initialized when the play button is clicked
    </script>
</body>
</html>