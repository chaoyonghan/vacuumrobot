<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vacuum Robot Game</title>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background-color: #f0f9ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            user-select: none;
            max-width: 100%;
            overflow-x: hidden;
            margin: 0;
        }
        
        /* Start Page Styles */
        .start-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100%;
            background-color: #e0f7ff;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 100;
            transition: opacity 0.5s ease-in-out;
        }
        
        .start-title {
            font-size: 72px;
            color: #4dabf7;
            margin-bottom: 50px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.2);
            animation: float 3s infinite ease-in-out;
            text-align: center;
        }
        
        .play-button {
            padding: 15px 50px;
            font-size: 36px;
            background-color: #51cf66;
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 8px 15px rgba(0,0,0,0.2);
            transition: all 0.3s;
        }
        
        .play-button:hover {
            transform: scale(1.1);
            background-color: #40c057;
            box-shadow: 0 12px 20px rgba(0,0,0,0.25);
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-15px); }
        }
        
        /* Game Page Styles */
        .game-page {
            display: none; /* Initially hidden */
            padding-top: 20px;
        }
        
        .game-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-direction: row; /* Side by side layout */
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 320px;
            align-self: flex-start; /* Align with the top of the board */
        }
        
        .command-toolbar {
            display: flex;
            gap: 10px;
            background-color: #d1ecff;
            padding: 15px;
            border-radius: 8px;
            justify-content: center;
            flex-wrap: nowrap; /* Ensure commands stay in one line */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .command-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: #e6f7ff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(16, 80px);
            grid-template-rows: repeat(9, 80px);
            gap: 3px;
            background-color: #ddd;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .cell {
            width: 80px;
            height: 80px;
            background-color: #fff;
            background-image: url('images/wooden-floor.jpg');
            background-size: cover;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        /* Dust overlay on cells */
        .cell::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(120, 120, 120, 0.65); /* Semi-transparent gray dust with higher opacity */
            border-radius: 5px;
            pointer-events: none; /* Let clicks pass through */
            transition: opacity 2s ease; /* Smooth transition for dust returning */
            z-index: 3; /* Above content but below the robot */
        }
        
        /* Clean cell state */
        .cell.clean::after {
            opacity: 0; /* Dust disappears when cleaned */
        }
        
        .command {
            width: 45px;
            height: 45px;
            background-color: #fff;
            border: 2px solid #4dabf7;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        
        .command:hover {
            transform: scale(1.05);
        }
        
        .command img {
            width: 35px;
            height: 35px;
        }
        
        .sequence-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        .sequence-slots {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
        }
        
        .slot {
            width: 100%;
            height: 50px;
            background-color: #f8f9fa;
            border: 2px dashed #adb5bd;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .slot::before {
            content: attr(data-index);
            position: absolute;
            left: 10px;
            font-weight: bold;
            color: #adb5bd;
        }
        
        .slot.filled {
            border: 2px solid #4dabf7;
            background-color: #e7f5ff;
        }
        
        .start-button {
            padding: 10px 20px;
            background-color: #51cf66;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            margin-top: 5px;
        }
        
        .start-button:hover {
            transform: scale(1.05);
            background-color: #40c057;
        }
        
        .start-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            transform: none;
        }
        
        .robot {
            width: 70px;
            height: 70px;
            position: absolute;
            transition: transform 0.8s;
            z-index: 4; /* Higher than the dust layer */
            filter: drop-shadow(0 3px 3px rgba(0,0,0,0.2));
        }
        
        .mess {
            width: 60px;
            height: 60px;
            position: absolute;
            z-index: 2; /* Above the floor but below the dust */
        }
        
        .obstacle {
            width: 70px;
            height: 70px;
            position: absolute;
            z-index: 2; /* Above the floor but below the dust */
        }
        
        .current {
            background-color: #ffe066;
            border: 3px solid #ffd43b;
            box-shadow: 0 0 10px rgba(255, 212, 59, 0.5);
            animation: pulse 1s infinite;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .score-display {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            font-size: 24px;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            background-color: #fff5f5;
            border: 3px solid #ffc9c9;
            border-radius: 15px;
            padding: 10px 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: calc(16 * 80px + 15 * 3px + 20px); /* Match board width: 16 cells + 15 gaps + padding */
            box-sizing: border-box;
            margin-top: 10px;
            animation: pulse-light 2s infinite;
        }
        
        #score-value {
            font-weight: bold;
            font-size: 28px;
            color: #fa5252;
            margin-left: 5px;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 5px rgba(255, 212, 59, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 212, 59, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 212, 59, 0.5); }
        }
        
        @keyframes pulse-light {
            0% { box-shadow: 0 0 5px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: 0 0 5px rgba(255, 107, 107, 0.5); }
        }
        
        @keyframes clean {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        
        .cleaning {
            animation: clean 0.5s forwards;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0) rotate(var(--rotation, 0deg)); }
            50% { transform: translateY(-5px) rotate(var(--rotation, 0deg)); }
        }
        
        .bounce {
            animation: bounce 0.5s;
            --rotation: 0deg;
        }
        
        @keyframes collision {
            0%, 100% { transform: translateX(0) rotate(var(--rotation, 0deg)); }
            25% { transform: translateX(-5px) rotate(var(--rotation, 0deg)); }
            50% { transform: translateX(5px) rotate(var(--rotation, 0deg)); }
            75% { transform: translateX(-5px) rotate(var(--rotation, 0deg)); }
        }
        
        .collision {
            animation: collision 0.5s;
        }
        
        /* Preserve rotation during animation */
        .robot[style*="rotate(-90deg)"] {
            --rotation: -90deg;
        }
        
        .robot[style*="rotate(90deg)"] {
            --rotation: 90deg;
        }
        
        .robot[style*="rotate(180deg)"] {
            --rotation: 180deg;
        }
    </style>
</head>
<body>
    <!-- Start Page -->
    <div class="start-page" id="start-page">
        <h1 class="start-title">Vacuum Robot Game</h1>
        <button class="play-button" id="play-button">PLAY</button>
    </div>
    
    <!-- Game Page -->
    <div class="game-page" id="game-page">
        <div class="game-container">
            <!-- Left Column: Command Bar and Sequence List -->
            <div class="left-panel">
                <!-- Command Selection Bar on top -->
                <div class="command-toolbar">
                    <div class="command" data-type="forward" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Forward" id="forward-img">
                    </div>
                    <div class="command" data-type="left" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Turn Left" id="left-img">
                    </div>
                    <div class="command" data-type="right" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Turn Right" id="right-img">
                    </div>
                    <div class="command" data-type="uturn" draggable="true">
                        <img src="/api/placeholder/50/50" alt="U-Turn" id="uturn-img">
                    </div>
                    <div class="command" data-type="clean" draggable="true">
                        <img src="/api/placeholder/50/50" alt="Clean" id="clean-img">
                    </div>
                </div>
                
                <!-- Command Panel with Sequence list below -->
                <div class="command-panel">
                    <button class="start-button" id="start-button">▶ Start</button>
                    <div class="sequence-list">
                        <div class="sequence-slots" id="sequence-slots">
                            <!-- Command slots will be generated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Right Column: Game Board and Score -->
            <div class="right-panel">
                <!-- Game Board on top -->
                <div class="board" id="game-board">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
                
                <!-- Score display below the board -->
                <div class="score-display">
                    <span>Score:</span>
                    <span id="score-value">0</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game variables
        const GRID_COLS = 16;
        const GRID_ROWS = 9;
        const MAX_OBJECTS = 8; // Reduced to make room for obstacles
        const MAX_OBSTACLES = 5; // Number of obstacles to spawn
        const MAX_COMMANDS = 10;
        const MOVE_DELAY = 1200; // milliseconds between command execution
        
        let score = 0;
        
        let robot = {
            x: 0,
            y: 0,
            direction: 'right', // 'up', 'right', 'down', 'left'
            element: null,
            isMoving: false
        };
        
        let messes = [];
        let obstacles = []; // New array to track obstacles
        let commandSequence = [];
        let isRunning = false;
        
        // Visual resources using local image files
        const messImages = [
            'images/spider.png',      // spider
            'images/icecream.png',    // ice cream
            'images/bread.png',       // bread
            'images/pan.png',         // pan
            'images/oil.png'          // oil
        ];
        
        // Obstacle images
        const obstacleImages = [
            'images/sofa.png', // Sofa
            'images/table.png', // Table
            'images/toy.png'  // Toy
        ];
        
        // Play button to start the game
        document.getElementById('play-button').addEventListener('click', function() {
            // Hide start page with a fade effect
            const startPage = document.getElementById('start-page');
            startPage.style.opacity = 0;
            
            // Show game page after fade
            setTimeout(() => {
                startPage.style.display = 'none';
                document.getElementById('game-page').style.display = 'block';
                initGame(); // Initialize the game after showing the game page
            }, 500);
        });
        
        // Initialize the game
        function initGame() {
            createBoard();
            createCommandSlots();
            setupDragAndDrop();
            placeRobot();
            spawnRandomObstacles(); // Place obstacles first
            spawnRandomMesses();     // Then place messes
            
            // Clean the starting cell (robot's position)
            cleanCell(robot.x, robot.y);
            
            // Reset score
            score = 0;
            document.getElementById('score-value').textContent = score;
            
            // Set up start button
            document.getElementById('start-button').addEventListener('click', startExecution);
            
            // Command icons
            document.getElementById('forward-img').src = 'images/forward.png';
            document.getElementById('left-img').src = 'images/left.png';
            document.getElementById('right-img').src = 'images/right.png';
            document.getElementById('uturn-img').src = 'images/uturn.png';
            document.getElementById('clean-img').src = 'images/clean.png';
        }
        
        // Create the game board
        function createBoard() {
            const board = document.getElementById('game-board');
            board.innerHTML = '';
            
            for (let y = 0; y < GRID_ROWS; y++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    board.appendChild(cell);
                }
            }
        }
        
        // Create command sequence slots
        function createCommandSlots() {
            const slotsContainer = document.getElementById('sequence-slots');
            slotsContainer.innerHTML = '';
            
            for (let i = 0; i < MAX_COMMANDS; i++) {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.dataset.index = i + 1;
                slotsContainer.appendChild(slot);
            }
        }
        
        // Place the robot at the start position
        function placeRobot() {
            robot.x = 0;
            robot.y = GRID_ROWS - 1; // Bottom-left corner
            robot.direction = 'up';  // Starting facing up
            
            if (!robot.element) {
                // Create a container for the robot image
                robot.element = document.createElement('div');
                robot.element.className = 'robot';
                
                // Use the provided image file
                const robotImg = document.createElement('img');
                robotImg.src = 'images/vacuumrobot.png';
                robotImg.alt = 'Vacuum Robot';
                robotImg.style.width = '70px';
                robotImg.style.height = '70px';
                robotImg.style.borderRadius = '50%'; // Keep circular shape
                robotImg.style.transform = 'rotate(90deg)'; // Rotate the image 90° clockwise
                
                robot.element.appendChild(robotImg);
            }
            
            updateRobotPosition();
        }
        
        // Clean the cell when the robot moves over it
        function cleanCell(x, y) {
            const cell = getCellAt(x, y);
            if (cell) {
                // Add the clean class to make the cell appear clean
                cell.classList.add('clean');
                
                // Set a timer to gradually make the cell dusty again
                setTimeout(() => {
                    // Only make it dusty if the robot is no longer on this cell
                    if (cell && !(robot.x === x && robot.y === y)) {
                        cell.classList.remove('clean');
                    }
                }, 16000); // Dust returns after 16 seconds (2x slower)
            }
        }
        
        // Update the robot's visual position and rotation
        function updateRobotPosition() {
            const cell = getCellAt(robot.x, robot.y);
            if (cell && robot.element) {
                cell.appendChild(robot.element);
                
                // Clean the current cell
                cleanCell(robot.x, robot.y);
                
                // Update rotation based on direction
                switch (robot.direction) {
                    case 'up':
                        robot.element.style.transform = 'rotate(-90deg)';
                        break;
                    case 'right':
                        robot.element.style.transform = 'rotate(0deg)';
                        break;
                    case 'down':
                        robot.element.style.transform = 'rotate(90deg)';
                        break;
                    case 'left':
                        robot.element.style.transform = 'rotate(180deg)';
                        break;
                }
                
                // Small bounce animation when moving
                robot.element.classList.add('bounce');
                setTimeout(() => {
                    robot.element.classList.remove('bounce');
                }, 500);
            }
        }
        
        // Get cell element at coordinates
        function getCellAt(x, y) {
            return document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
        }
        
        // Spawn random obstacles on the board
        function spawnRandomObstacles() {
            obstacles = []; // Clear existing obstacles
            
            const safeZone = { // Define a safe zone around the robot's starting position
                minX: 0,
                maxX: 2,
                minY: GRID_ROWS - 3,
                maxY: GRID_ROWS - 1
            };
            
            let count = 0;
            while (count < MAX_OBSTACLES) {
                const x = Math.floor(Math.random() * GRID_COLS);
                const y = Math.floor(Math.random() * GRID_ROWS);
                
                // Don't place in the safe zone
                if (x >= safeZone.minX && x <= safeZone.maxX && 
                    y >= safeZone.minY && y <= safeZone.maxY) {
                    continue;
                }
                
                // Don't place where another obstacle exists
                if (obstacles.some(o => o.x === x && o.y === y)) {
                    continue;
                }
                
                const cell = getCellAt(x, y);
                
                // Remove dust from cells with obstacles
                cell.classList.add('clean');
                
                const obstacleElement = document.createElement('img');
                obstacleElement.className = 'obstacle';
                
                // Pick a random obstacle image
                const imageIndex = Math.floor(Math.random() * obstacleImages.length);
                obstacleElement.src = obstacleImages[imageIndex];
                
                // Set alt text based on obstacle type
                switch(imageIndex) {
                    case 0:
                        obstacleElement.alt = 'Sofa';
                        break;
                    case 1:
                        obstacleElement.alt = 'Table';
                        break;
                    case 2:
                        obstacleElement.alt = 'Toy';
                        break;
                }
                
                cell.appendChild(obstacleElement);
                
                obstacles.push({
                    x: x,
                    y: y,
                    element: obstacleElement,
                    type: obstacleElement.alt
                });
                
                count++;
            }
        }
        
        // Spawn random messes on the board
        function spawnRandomMesses() {
            // Clear existing messes that aren't already on the board
            messes = messes.filter(mess => document.body.contains(mess.element));
            
            // Add new messes if we're below the maximum
            while (messes.length < MAX_OBJECTS) {
                const x = Math.floor(Math.random() * GRID_COLS);
                const y = Math.floor(Math.random() * GRID_ROWS);
                
                // Don't place mess on robot
                if (x === robot.x && y === robot.y) continue;
                
                // Don't place mess where one already exists
                if (messes.some(m => m.x === x && m.y === y)) continue;
                
                // Don't place mess where an obstacle exists
                if (obstacles.some(o => o.x === x && o.y === y)) continue;
                
                const cell = getCellAt(x, y);
                
                // Remove dust from cells with messes
                cell.classList.add('clean');
                
                const messElement = document.createElement('img');
                messElement.className = 'mess';
                
                // Pick a random mess image
                const imageIndex = Math.floor(Math.random() * messImages.length);
                messElement.src = messImages[imageIndex];
                messElement.alt = 'Mess';
                
                cell.appendChild(messElement);
                
                messes.push({
                    x: x,
                    y: y,
                    element: messElement
                });
            }
        }
        
        // Set up drag and drop functionality
        function setupDragAndDrop() {
            const commands = document.querySelectorAll('.command');
            const slots = document.querySelectorAll('.slot');
            
            commands.forEach(command => {
                command.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', command.dataset.type);
                    setTimeout(() => {
                        command.style.opacity = '0.4';
                    }, 0);
                });
                
                command.addEventListener('dragend', () => {
                    command.style.opacity = '1';
                });
            });
            
            slots.forEach(slot => {
                slot.addEventListener('dragover', e => {
                    e.preventDefault();
                    slot.style.backgroundColor = '#e7f5ff';
                });
                
                slot.addEventListener('dragleave', () => {
                    slot.style.backgroundColor = '';
                });
                
                slot.addEventListener('drop', e => {
                    e.preventDefault();
                    const commandType = e.dataTransfer.getData('text/plain');
                    const index = parseInt(slot.dataset.index);
                    
                    // Clear existing command in this slot
                    while (slot.firstChild) {
                        slot.removeChild(slot.firstChild);
                    }
                    
                    // Add new command
                    const commandImg = document.createElement('img');
                    commandImg.style.width = '35px';
                    commandImg.style.height = '35px';
                    
                    switch (commandType) {
                        case 'forward':
                            commandImg.src = 'images/forward.png';
                            commandImg.alt = '↑';
                            break;
                        case 'left':
                            commandImg.src = 'images/left.png';
                            commandImg.alt = '←';
                            break;
                        case 'right':
                            commandImg.src = 'images/right.png';
                            commandImg.alt = '→';
                            break;
                        case 'uturn':
                            commandImg.src = 'images/uturn.png';
                            commandImg.alt = '↺';
                            break;
                        case 'clean':
                            commandImg.src = 'images/clean.png';
                            commandImg.alt = '✓';
                            break;
                    }
                    
                    slot.appendChild(commandImg);
                    slot.classList.add('filled');
                    slot.dataset.command = commandType;
                    
                    // Update command sequence
                    commandSequence[index] = commandType;
                    
                    // Show animation feedback
                    slot.classList.add('bounce');
                    setTimeout(() => {
                        slot.classList.remove('bounce');
                    }, 500);
                });
                
                // Double click to remove command
                slot.addEventListener('dblclick', () => {
                    // Clear slot
                    while (slot.firstChild) {
                        slot.removeChild(slot.firstChild);
                    }
                    
                    slot.classList.remove('filled');
                    delete slot.dataset.command;
                    
                    // Update command sequence
                    const index = parseInt(slot.dataset.index);
                    commandSequence[index] = null;
                });
            });
        }
        
        // Start executing the command sequence
        function startExecution() {
            if (isRunning) return;
            
            // Clear any existing highlights
            document.querySelectorAll('.slot').forEach(slot => {
                slot.classList.remove('current');
            });
            
            // Sort commands by slot index and collect them
            const filledSlots = Array.from(document.querySelectorAll('.slot'))
                .filter(slot => slot.dataset.command)
                .sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));
                
            commandSequence = filledSlots.map(slot => slot.dataset.command);
            
            if (commandSequence.length === 0) return;
            
            isRunning = true;
            document.getElementById('start-button').disabled = true;
            
            // Disable drag and drop during execution
            document.querySelectorAll('.command').forEach(cmd => {
                cmd.setAttribute('draggable', 'false');
                cmd.style.cursor = 'default';
            });
            
            executeCommands();
        }
        
        // Execute commands one by one
        function executeCommands() {
            let currentIndex = 0;
            const slots = document.querySelectorAll('.slot');
            
            // Clear any previous highlights first
            slots.forEach(slot => slot.classList.remove('current'));
            
            function executeNext() {
                if (currentIndex >= commandSequence.length || !isRunning) {
                    endExecution();
                    return;
                }
                
                // Find the slot corresponding to the current command
                const currentSlot = Array.from(slots).find(slot => 
                    parseInt(slot.dataset.index) === currentIndex + 1 && 
                    slot.dataset.command === commandSequence[currentIndex]
                );
                
                // Highlight current command
                if (currentSlot) {
                    slots.forEach(slot => slot.classList.remove('current'));
                    currentSlot.classList.add('current');
                    // Scroll to the current command if needed
                    currentSlot.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                
                const command = commandSequence[currentIndex];
                executeCommand(command);
                
                currentIndex++;
                setTimeout(executeNext, MOVE_DELAY);
            }
            
            executeNext();
        }
        
        // Execute a single command
        function executeCommand(command) {
            switch (command) {
                case 'forward':
                    moveForward();
                    break;
                case 'left':
                    turnLeft();
                    break;
                case 'right':
                    turnRight();
                    break;
                case 'uturn':
                    turnAround();
                    break;
                case 'clean':
                    clean();
                    break;
            }
        }
        
        // Move the robot forward
        function moveForward() {
            let newX = robot.x;
            let newY = robot.y;
            
            switch (robot.direction) {
                case 'up':
                    newY--;
                    break;
                case 'right':
                    newX++;
                    break;
                case 'down':
                    newY++;
                    break;
                case 'left':
                    newX--;
                    break;
            }
            
            // Check if the new position is within bounds
            if (newX >= 0 && newX < GRID_COLS && newY >= 0 && newY < GRID_ROWS) {
                // Check if there's an obstacle in the way
                const obstacleIndex = obstacles.findIndex(obstacle => 
                    obstacle.x === newX && obstacle.y === newY
                );
                
                if (obstacleIndex !== -1) {
                    // Hit an obstacle - show collision animation and end execution
                    robot.element.classList.add('collision');
                    setTimeout(() => {
                        robot.element.classList.remove('collision');
                    }, 500);
                    
                    // Show what obstacle was hit
                    console.log(`Robot hit a ${obstacles[obstacleIndex].type}!`);
                    
                    // End execution after animation
                    setTimeout(() => {
                        endExecution();
                    }, 600);
                } else {
                    // Move to the new position
                    robot.x = newX;
                    robot.y = newY;
                    updateRobotPosition();
                }
            } else {
                // Hit the border, stop execution
                robot.element.classList.add('collision');
                setTimeout(() => {
                    robot.element.classList.remove('collision');
                }, 500);
                
                setTimeout(() => {
                    endExecution();
                }, 600);
            }
        }
        
        // Turn the robot left
        function turnLeft() {
            switch (robot.direction) {
                case 'up':
                    robot.direction = 'left';
                    break;
                case 'right':
                    robot.direction = 'up';
                    break;
                case 'down':
                    robot.direction = 'right';
                    break;
                case 'left':
                    robot.direction = 'down';
                    break;
            }
            updateRobotPosition();
        }
        
        // Turn the robot right
        function turnRight() {
            switch (robot.direction) {
                case 'up':
                    robot.direction = 'right';
                    break;
                case 'right':
                    robot.direction = 'down';
                    break;
                case 'down':
                    robot.direction = 'left';
                    break;
                case 'left':
                    robot.direction = 'up';
                    break;
            }
            updateRobotPosition();
        }
        
        // Turn the robot around (180 degrees)
        function turnAround() {
            switch (robot.direction) {
                case 'up':
                    robot.direction = 'down';
                    break;
                case 'right':
                    robot.direction = 'left';
                    break;
                case 'down':
                    robot.direction = 'up';
                    break;
                case 'left':
                    robot.direction = 'right';
                    break;
            }
            updateRobotPosition();
        }
        
        // Clean the current cell
        function clean() {
            const messIndex = messes.findIndex(mess => 
                mess.x === robot.x && mess.y === robot.y
            );
            
            if (messIndex !== -1) {
                const mess = messes[messIndex];
                mess.element.classList.add('cleaning');
                
                // Increase score
                score += 1;
                document.getElementById('score-value').textContent = score;
                
                // Add score animation
                const scoreElement = document.getElementById('score-value');
                scoreElement.classList.add('bounce');
                setTimeout(() => {
                    scoreElement.classList.remove('bounce');
                }, 500);
                
                // Remove the mess after animation
                setTimeout(() => {
                    if (mess.element.parentNode) {
                        mess.element.parentNode.removeChild(mess.element);
                    }
                    messes.splice(messIndex, 1);
                    
                    // Spawn a new mess
                    setTimeout(spawnRandomMesses, 500);
                }, 500);
            }
        }
        
        // End command execution
        function endExecution() {
            isRunning = false;
            document.getElementById('start-button').disabled = false;
            
            // Re-enable drag and drop
            document.querySelectorAll('.command').forEach(cmd => {
                cmd.setAttribute('draggable', 'true');
                cmd.style.cursor = 'grab';
            });
            
            // Remove highlighting
            document.querySelectorAll('.slot').forEach(slot => {
                slot.classList.remove('current');
            });
            
            // Clear sequence list immediately
            document.querySelectorAll('.slot').forEach(slot => {
                // Remove any children
                while (slot.firstChild) {
                    slot.removeChild(slot.firstChild);
                }
                // Clear classes and data attributes
                slot.classList.remove('filled');
                delete slot.dataset.command;
            });
            
            // Reset command sequence array
            commandSequence = [];
        }
        
        // Note: We don't initialize the game here anymore
        // It will be initialized when the play button is clicked
    </script>
</body>
</html>